---
layout: post
title: JVM 类加载机制
categories: [JVM]
description: JVM 类加载机制
keywords: JVM, 类加载机制
---

# 概述
> Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。

# 类的生命周期
类的生命周期分为——加载、验证、准备、解析、初始化、使用、卸载七个阶段。其中验证、准备、解析三个阶段被统称为连接。

![类的生命周期，图片来源《深入理解Java虚拟机（第三版）》](https://user-gold-cdn.xitu.io/2020/4/21/1719a6976a62969a?w=926&h=303&f=png&s=73812)

> 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

## 加载
查找并加载类的二进制字节流到虚拟机中

- 虚拟机通过类的全限定名来获取定义此类的二进制字节流，然后将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 通过启动时添加JVM参数——`-XX:+TraceClassLoading`，打开打印类的加载顺序功能。

## 连接
验证、准备、解析三个阶段被统称为连接。

### 验证
确保被加载类的正确性。验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。  
> 验证阶段的四个检验动作参见《深入理解Java虚拟机（第三版）》7.3.2 验证。

### 准备
为类的静态变量分配内存，并将其初始化为默认值。

- 如果类字段的字段属性表中存在`ConstantValue`属性（被final修饰），那在准备阶段变量值就会被初始化为`ConstantValue`属性所指定的初始值。
- 各类型的默认值
    - `int -> 0`
    - `float -> 0.0f`
    - `double -> 0.0d`
    - `short -> (short)0`
    - `long -> 0L`
    - `char -> '\u0000'`
    - `boolean -> false`
    - `byte -> (byte)0`
    - 引用类型默认值：`null`
> [示例代码地址](https://github.com/Planeswalker23/all-in-one/tree/master/source-code/jvm/src/main/java/classloader/prepare)

### 解析
将常量池内的符号引用替换为直接引用。

## 初始化
为类的静态变量赋予正确的初始值。
> [示例代码地址](https://github.com/Planeswalker23/all-in-one/tree/master/source-code/jvm/src/main/java/classloader/initialize)

### 初始化的时机
所有的Java虚拟机实现必须在每个类或接口被“首次主动使用”时才进行初始化。

#### 主动引用
《Java虚拟机规范》严格规定了有且只有六种情况（这六种行为被称为对一个类型进行主动引用），如类型没有进行过初始化，必须立即对类进行“初始化”：
1. 遇到`new、getstatic、putstatic、invokestatic`这四条字节码指令时。能够生成这四条指令的典型Java代码场景有：
    - 创建类的实例(new Object)
    - 读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）
    - 调用一个类型的静态方法
2. 使用`java.lang.reflect`包的方法对类型进行反射调用
3. 当初始化类的时候，如果父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 虚拟机启动时被标为启动类的类（包含main()方法）
5. 当使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandl`e实例最后的解析结果为`REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

#### 被动引用
除了主动引用之外所有引用类型的方式都不会触发初始化，称为被动引用。
- 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
- 通过数组定义来引用类，不会触发此类的初始化。
    - 为什么创建引用类型数组不会触发该引用类型的初始化：创建引用类型的数组会初始化一个由虚拟机自动生成的、直接继承于java.lang.Object的类。它在字节码中被表示为`[com.haha.User`。（[右边是类的包名+类名，二维数组表示为`[[com.haha.User`）
    - 字节码在创建此类时使用的助记符是：`anewarray`
    - 若创建原始类型的数组，使用的助记符是：`newarray`，在字节码中被表示为：
        - `[I -> (int)`
        - `[F -> (float)`
        - `[D -> (double)`
        - `[S -> (short)`
        - `[J -> (long)`
        - `[C -> (char)`
        - `[Z -> (boolean)`
        - `[B -> (byte)`
- 常量在编译阶段会存入调用该常量的类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
    - 当一个常量的值在编译器不确定时(如`UUID.random().toString()`)，那么它不会被放到调用类的常量池中。在程序运行时，会主动使用这个常量所在的类，导致该类被初始化。

#### 常量池
在被动引用中讲到了类的常量池，在这里记录一下一些的助记符。
- ldc: 表示将int、float、String类型的常量推送至栈顶
- bipush: 表示将单字节常量（-128~127）推送至栈顶
- sipush: 表示将短整型常量（-32768~32767）推送至栈顶
- iconst_0: 表示将int类型的0推送至栈顶（-1~5, `iconst_m1`~`iconst5`）

#### 接口初始化与类初始化的不同处
在接口的初始化过程中，编译器会为接口生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。

接口与类真正有所区别的是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

- 验证：根据“初始化阶段虚拟机会给静态变量赋值”这一条原则，在父类接口中定义一个`int a = 1/0;`，如果触发类的初始化，会将1/0赋值给a，从而抛出`java.lang.ArithmeticException: / by zero`异常。结果也正如以上的描述，抛出了该异常。证明子接口在使用到父接口的时候会初始化父接口。
 
````
public class InterfaceDemo {

    public static void main(String[] args) {
        // 调用子接口的常量，父接口不初始化
        System.out.println(ChildInterface.parentRight);
    }
}

interface ParentInterface {
    int parentWrong = 2 / 0;
    String parentRight = UUID.randomUUID().toString();
}

interface ChildInterface extends ParentInterface {
    int childI = 1;
}
````

# 双亲委派机制
## 详细描述
当类加载器接收到类加载的请求时，它不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一个层次的类加载器都是如此，因此所有的请求最终都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围内没有找到所需的类)时，子加载器才会尝试自己去加载。

## 双亲委派机制的好处
1. 避免重复加载。Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
2. 避免核心类篡改。Java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java
API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

## 类加载器分类
1. 启动类加载器`Bootstrap ClassLoader`
    - 负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别,如rt.jar、tools.jar,名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机中。

2. 拓展类加载器`Extension ClassLoader`
    - 负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径的所有类。

3. 应用程序加载器`Application ClassLoader`
    - 负责加载用户类路径(ClassPath)上所指定的类库。如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。

4. 用户自定义类加载器`CustomClassLoader`
    - 用户自定义的类加载器,可加载指定路径的class文件