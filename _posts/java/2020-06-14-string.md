---
layout: post
title: 面试官：你真的理解String吗
categories: [Java]
description: 面试官：你真的理解String吗
keywords: String
---

前几天后端君在自我提高（摸鱼）的时候看到了一个简单却也有趣的面试题：`String str = new String("abc")`这个语句创建了几个对象？

这是一个非常常见的面试题，个人觉得能很好的甄别候选者`Java`水平的深度——`String`类用谁都会用，如果还知道它的底层实现以及原理，那就知道此人不是泛泛之辈，然后可以再深入聊聊`JVM`内存结构等等逐渐拓展开去了。

其实在很多面试题汇总的帖子中可能也都会收录这个问题，并且给出详细且准确的回答，在网上搜索这个问题也会有很多答案。那后端君今天说这个的原因就是想从这道面试题入手，和大家一起深入学习一下`String`这个可以说在`Java`中最常用的类（没有之一）。

希望日后无论是在面试中，还是在日常开发中，可以对String类更游刃有余。

![2020061402](https://planeswalker23.github.io/images/posts/2020061402.png)

## 1. String 的底层结构
首先先来了解一下`String`的底层结构，在后端君所用的`JDK`版本`1.8`中，`String`类是通过一个`char`数组来存储字符串的。

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    // 用于存储字符串
    private final char value[];
    // 缓存字符串哈希值，默认为0
    private int hash;
    // 省略
}
```

可能很多同学也都注意到了`String`类是被`final`关键字修饰的，用于存储字符串的`char`数组也是被`final`关键字修饰的。这样设计的原因其实是保证了`String`的不可变性，包括`String`对象不可被继承，字符数组`value`属性的引用地址不可修改。

至于为什么要保证它不可变？别问，问就是设计，`JDK`工程师们精心的设计！

![2020061403](https://planeswalker23.github.io/images/posts/2020061403.png)

## 2. String被final修饰的原因

事实上，`String`类被设计成被`final`修饰确实是有它一定的道理的。

首先第一原因是高效，就拿常量池来说，只有变量是不可修改的，才能够被缓存起来，从而实现常量池的功能。同时，被`final`修饰意味着不可被修改，所以不需要考虑它的值被修改。

第二个原因是安全，`Java`之父`James Gosling`解释过，迫使`String`类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题。

在这里需要着重提到的是，虽然`String`对象的字符数组`value`属性是不可变的，但只是引用地址不可变，如果直接修改`value`属性的内容，还是可以成功的。

```java
final char[] str = {'1','2','3'};
// 直接赋值将 str 数组的内容修改为{'1','2','4'}
str[2] = '4';
//  通过反射将 str 数组的内容修改为{'1','2','5'}
java.lang.reflect.Array.set(str, 2, '5');
```

以上两种方法都是没有改变一个被`final`修饰的变量的引用地址，而是直接修改引用所代表的数组元素，成功修改了一个被`final`修饰的变量的内容。

![2020061404](https://planeswalker23.github.io/images/posts/2020061404.png)

## 3. String 的创建流程
明白了`String`类的底层存储结构之后，我们再来看它的创建流程，回想一下文本刚开始提到的那个问题，`String str = new String("abc")`这个语句创建了几个对象？

再提出一个问题进行对比：`String str = "abc"`与`String str = new String("abc")`有什么区别吗？

在回答这两个问题之前，我们必须知道一些概念。如果有了解过`JVM`的同学会知道，虚拟机中有一个地方叫常量池，它会存储字符串常量，在`JDK1.7`之后常量池位于`Java`堆中。在程序中创建的对象实例，也会被存放在`Java`堆中，但与常量池存放的位置是不一样的。还有就是，对象的引用变量如上述代码中的`str`，会被存放在虚拟机栈中。

上面提出的第二个问题说到了`String`对象的两种创建方式：直接赋值和`new`。

### 3.1 直接赋值
首先来说直接赋值，首先会去常量池中寻找`abc`字符串是否存在，若已存在会将`str`引用变量直接指向常量池中的值。如果不存在，会在常量池中先创建一个`abc`字符串，然后把`str`指向刚刚创建出来的`abc`字符串。

### 3.2 new String()
而对于使用`new`关键词来创建一个`String`对象，首先虚拟机会在`Java`堆中创建一个`String`对象，然后再去常量池中寻找`abc`字符串是否存在，如果不存在会在常量池中创建一个`abc`字符串，然后把`Java`堆中的对象引用的值指向在常量池中创建的`abc`字符串；若常量池中已存在`abc`字符串，不会创建该字符串，也不会改变`Java`堆中对象的引用值。

综上所述，`String str = new String("abc")`这个语句，会创建1个或2个对象，若常量池中没有`abc`字符串，那么会创建2个对象，否则只会在`Java`堆中创建一个对象。

而直接赋值语句会创建0个或1个对象，若常量池中没有`abc`字符串，会创建1个对象，否则不会创建对象，只需要将引用指向常量池中的`abc`字符串。

### 3.3 代码示例
我们写两个例子验证一下上面的结论。

```java
public static void main(String[] args) {
    String a = new String("abc");
    String b = "abc";
    System.out.println(a==b);
}
```

我们画一张图来描述一下示例代码中对象之间的关系。

![2020061406](https://planeswalker23.github.io/images/posts/2020061406.png)

第一行代码中使用`new String("abc")`创建了一个对象，所以会在堆中创建一个`value[]`对象，而此时常量池不存在`abc`字符串，所以会在常量池中创建此字符串，并将`value[]`对象的引用值指向常量池中的`abc`字符串，但是这两个值的地址是不一样的。

第二行代码中使用直接赋值的方式，由于常量池中`abc`字符串已经存在，所以`b`这个引用变量会直接指向常量池中的`abc`字符串。

最后，由于`value[]`对象的地址与常量池中`abc`字符串的地址是不一样的，所以`a`与`b`是不相等的。

## 4. 小结
今天讲述了关于`String`类的几个方面：底层结构、用`final`修饰的原因、对象创建流程。

如果以后在面试中遇到类似的问题千万不要答不上来啦！

希望能够帮助到大家。


> 版权声明：本文为[Planeswalker23](https://github.com/Planeswalker23)所创，转载请带上原文链接，感谢。<br>
> 本文已上传个人公众号，欢迎扫码关注。

![wechat](https://planeswalker23.github.io/images/wechat.png)